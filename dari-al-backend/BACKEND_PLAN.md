# Пошаговый план разработки бэкенда Dari Al

План учитывает возможные ошибки, безопасность, валидацию и отказоустойчивость на каждом шаге.

---

## Фаза 0: Подготовка окружения

### Шаг 0.1 — Выбор HTTP-фреймворка
- **Варианты:** Javalin (легкий), Spring Boot (полноценный), Micronaut.
- **Рекомендация:** Javalin — минималистичный, без магии, хорошо сочетается с текущим стилем (ручной DataSource, репозитории).
- **Действие:** Добавить в `pom.xml` зависимость Javalin (или выбранный фреймворк). Убедиться, что версия Java в maven-compiler-plugin — 17 (как в properties).

### Шаг 0.2 — Единый формат ответов и ошибок
- **Проблема:** Без единого формата фронт не сможет стабильно обрабатывать ответы.
- **Действие:**
  - Ввести DTO: `ApiResponse<T>` (например: `{ "success": true, "data": T }` или `{ "data": T, "error": null }`).
  - Ввести `ApiError` (код, сообщение, опционально `details`).
  - Для ошибок: HTTP status + тело `{ "success": false, "error": { "code": "...", "message": "..." } }`.
- **Предотвращение:** Все контроллеры возвращают только эти форматы; исключения перехватываются глобальным обработчиком (exception handler).

### Шаг 0.3 — Глобальный обработчик исключений
- **Цель:** Ни одна необработанная ошибка не уходит клиенту в виде stack trace.
- **Действие:**
  - В централизованном handler перехватывать: `SQLException` → 500, логировать, отдавать общее сообщение («Внутренняя ошибка»).
  - `IllegalArgumentException` / кастомный `ValidationException` → 400 с понятным сообщением.
  - Неизвестные `Exception` → 500, полный лог только на сервере.
- **Предотвращение:** Не логировать чувствительные данные (токены, пароли, коды). В ответе клиенту — только безопасный message.

---

## Фаза 1: База данных и миграции

### Шаг 1.1 — Структура миграций Flyway
- **Проблема:** Сейчас Flyway в зависимостях, но миграций нет — схема не версионирована.
- **Действие:**
  - Создать `src/main/resources/db/migration/`.
  - Именование: `V1__create_sms_codes.sql`, `V2__create_users.sql` и т.д. (одна «логическая» задача — один файл).

### Шаг 1.2 — Миграция V1: таблица sms_codes
- **Учесть:** В `JdbcSmsCodeRepository` используются: `id`, `phone`, `code_hash`, `expires_at`, `attempts_left`, `used_at`, а также `ORDER BY created_at` — значит нужна колонка `created_at`.
- **Действие:** Создать `V1__create_sms_codes.sql`:
  - `id BIGSERIAL PRIMARY KEY`
  - `phone VARCHAR(20) NOT NULL`
  - `code_hash VARCHAR(256) NOT NULL`
  - `expires_at TIMESTAMPTZ NOT NULL`
  - `attempts_left INT NOT NULL`
  - `used_at TIMESTAMPTZ NULL`
  - `created_at TIMESTAMPTZ NOT NULL DEFAULT now()`
  - Индекс по `(phone, created_at DESC)` для быстрого поиска последнего кода.
- **Предотвращение:** Ограничить длину `phone` (защита от переполнения). Не хранить сам код — только хеш.

### Шаг 1.3 — Инициализация Flyway при старте приложения
- **Проблема:** Миграции должны выполняться до первого обращения к БД.
- **Действие:** В точке входа (после создания DataSource) вызвать `Flyway.configure().dataSource(ds).load().migrate()`. При падении миграции — не стартовать приложение (fail-fast).

### Шаг 1.4 — Обработка ошибок миграций
- **Предотвращение:** В production не менять уже применённые миграции. Только добавлять новые (V3, V4…). При конфликте версий Flyway прерывает старт — так и должно быть.
- **Рекомендация:** В CI перед деплоем запускать `migrate` на тестовой БД с тем же набором миграций.

---

## Фаза 2: HTTP-сервер и CORS

### Шаг 2.1 — Поднятие Javalin (или выбранного фреймворка)
- **Действие:** В `App.java` (или отдельном классе): создать Javalin app, привязать к порту из `AppConfig.httpPort()`, запустить.
- **Предотвращение:** Обработать `BindException` (порт занят) — логировать понятную ошибку и завершать процесс с ненулевым кодом.

### Шаг 2.2 — CORS
- **Проблема:** Запросы с фронта (dari-al-health) с другого origin будут блокироваться браузером.
- **Действие:** Включить CORS для origin фронта (в dev — `http://localhost:5173` или тот, на котором крутится Vite). Разрешить нужные методы (GET, POST, PUT, DELETE) и заголовки (Content-Type, Authorization).
- **Предотвращение:** В production не использовать `*` для origin — указывать явный origin фронта.

### Шаг 2.3 — Health-check эндпоинт
- **Цель:** Проверка живости сервиса (K8s, балансировщик).
- **Действие:** `GET /health` → 200 + минимальное тело (например `{"status":"up"}`). Опционально: проверка подключения к БД (отдельный эндпоинт `/health/db`), при недоступности БД — 503.

### Шаг 2.4 — Безопасность заголовков
- **Действие:** Установить заголовки: `X-Content-Type-Options: nosniff`, при необходимости `Content-Security-Policy`. Не отдавать в ответах заголовки, раскрывающие версию сервера/фреймворка.

---

## Фаза 3: Авторизация (Auth API)

### Шаг 3.1 — Миграция V2: таблица users
- **Поля:** `id BIGSERIAL PRIMARY KEY`, `phone VARCHAR(20) NOT NULL UNIQUE`, `name VARCHAR(255)`, `created_at TIMESTAMPTZ NOT NULL DEFAULT now()`, `role VARCHAR(50)` (опционально).
- **Действие:** Создать `V2__create_users.sql`. Индекс по `phone` (уже есть UNIQUE).
- **Предотвращение:** Нормализовать телефон перед сохранением (убрать пробелы, скобки; единый формат, например E.164).

### Шаг 3.2 — UserRepository
- **Методы:** `findByPhone(Connection, String) -> Optional<User>`, `create(Connection, String, String) -> User`, при необходимости `updateName(Connection, long, String)`.
- **Действие:** Интерфейс + `JdbcUserRepository`. Все запросы — через PreparedStatement, параметры подставлять только через `?` (защита от SQL-инъекций).
- **Предотвращение:** В `create` использовать RETURNING или повторный SELECT, чтобы вернуть сгенерированный `id` и `created_at`.

### Шаг 3.3 — Доработка AuthService: создание/обновление пользователя после verify
- **Сейчас:** `verify` только проверяет код и помечает его использованным.
- **Действие:** После успешной проверки кода: если пользователь с таким `phone` есть — вернуть его; иначе создать через `UserRepository.create(phone, name?)`. Имя при первом входе можно пустое или передавать с фронта позже.
- **Транзакция:** Вся операция verify + find/create user в одной транзакции (один Connection, setAutoCommit(false), commit/rollback).

### Шаг 3.4 — Выдача токена после verify
- **Варианты:** JWT (stateless) или непрозрачный токен с хранением в БД (session).
- **Действие:** После успешного verify генерировать токен (JWT: id пользователя, expiry, подпись секретом из конфига). Секрет хранить в переменной окружения, не в коде. Добавить в конфиг: `jwtSecret`, `jwtExpirySeconds`.
- **Предотвращение:** Короткий срок жизни access-токена (например 24 часа). При необходимости — refresh-токен (отдельная таблица или поле в JWT с типом «refresh»).

### Шаг 3.5 — Эндпоинт POST /api/auth/send-code
- **Тело:** `{ "phone": "+7..." }`.
- **Валидация:** Телефон обязателен. Формат: цифры, допустимы + в начале, длина в разумных пределах (например 10–15 символов). Иначе — 400 с понятным сообщением.
- **Нормализация:** Привести телефон к единому формату перед вызовом `AuthService.sendCode(phone)`.
- **Ошибки:** Если SMS-провайдер недоступен — поймать исключение, залогировать, вернуть 503 («Сервис отправки SMS временно недоступен»). Не раскрывать детали провайдера.
- **Rate limiting (критично):** Ограничить количество запросов send-code на один телефон (например 1 раз в 60 секунд) и с одного IP (например 5 запросов в минуту). Иначе — риск спама и перерасхода SMS.
- **Действие:** Сохранять в кэш/БД время последней отправки по phone (и по IP при необходимости). Перед вызовом `sendCode` проверять лимит; при превышении — 429 Too Many Requests.
- **Ответ при успехе:** 200 + `{ "success": true }` или 204 No Content. Не сообщать, существует ли пользователь с таким телефоном (одинаковый ответ для существующего и несуществующего).

### Шаг 3.6 — Эндпоинт POST /api/auth/verify
- **Тело:** `{ "phone": "+7...", "code": "123456" }`.
- **Валидация:** Оба поля обязательны. Код — цифры, фиксированная длина (например 4–6). Иначе 400.
- **Действие:** Нормализовать phone, вызвать `AuthService.verify(phone, code)`. При успехе — создать/получить User, сгенерировать JWT, вернуть `{ "token": "...", "user": { "id", "phone", "name" } }`.
- **При неуспехе:** 401 Unauthorized, сообщение «Неверный или истёкший код». Не уточнять, истёк ли код или неверный (защита от перебора).
- **Rate limiting:** Ограничить попытки verify по паре (phone, code) или по IP (например 10 попыток в 15 минут). При превышении — 429.

### Шаг 3.7 — Эндпоинт GET /api/auth/me
- **Заголовок:** `Authorization: Bearer <token>`.
- **Действие:** Распарсить JWT, проверить подпись и срок действия. По id из токена загрузить User из БД (чтобы убедиться, что пользователь не удалён). Вернуть данные пользователя.
- **Ошибки:** Нет заголовка / неверный формат / невалидный или истёкший токен → 401. Пользователь не найден в БД → 401.
- **Предотвращение:** Не возвращать чувствительные поля (если появятся — не отдавать хеши паролей и т.п.).

### Шаг 3.8 — Защита эндпоинтов по токену
- **Действие:** Вынести в middleware/фильтр: для маршрутов под префиксом `/api/orders`, `/api/favorites`, `/api/profile` требовать валидный JWT. Если токена нет или он невалиден — 401 до вызова обработчика.
- **Исключения:** `/api/auth/*`, `/api/products`, `/api/categories`, `/health` — публичные (products/categories читают все).

### Шаг 3.9 — Исправление опечатки в конфиге
- **Сейчас:** В `AppConfig` используется переменная `OPT_SECRET` (опечатка: должно быть OTP).
- **Действие:** Поддержать оба варианта: `OTP_SECRET` и `OPT_SECRET` (для обратной совместимости), приоритет у `OTP_SECRET`.

### Шаг 3.10 — Реальная генерация OTP
- **Сейчас:** `OtpGenerator` возвращает константу `"1234"`.
- **Действие:** Генерировать случайный код (например 4–6 цифр) через `SecureRandom`. Не использовать `Random` — только криптостойкий генератор.
- **Предотвращение:** Одинаковая длина кодов (чтобы по времени ответа нельзя было угадать длину).

---

## Фаза 4: Каталог (Products, Categories)

### Шаг 4.1 — Миграция V3: категории и товары
- **Таблица categories:** `id VARCHAR(50) PRIMARY KEY`, `name VARCHAR(255)`, `icon VARCHAR(10)`, `subcategories TEXT[]` или JSONB (если PostgreSQL). Альтернатива: отдельная таблица subcategories.
- **Таблица products:** поля по модели фронта: id (UUID или BIGSERIAL), name, category_id (FK), subcategory, form, dosage, manufacturer, price, old_price, stock, description, indications, contraindications, usage, image_url, is_hit, is_new, is_sale, created_at.
- **Действие:** Создать миграции, индексы: по `category_id`, по `price` (для сортировки), полнотекстовый по name/description (опционально, для поиска).
- **Предотвращение:** NOT NULL где нужно, CHECK (price >= 0), CHECK (stock >= 0). Уникальность id.

### Шаг 4.2 — ProductRepository и CategoryRepository
- **CategoryRepository:** `findAll()`, при необходимости `findById(id)`.
- **ProductRepository:** `findById(id)`, `findAll(filters, sort, limit, offset)`. Фильтры: categoryId, search (текст), form, manufacturer, priceMin, priceMax, isSale, isNew. Сортировка: popular (is_hit), price_asc, price_desc, name, new.
- **Действие:** Все запросы параметризованные. При поиске по тексту — использовать безопасный паттерн (LIKE с экранированием или полнотекстовый поиск), не конкатенировать строку в SQL.
- **Предотвращение:** Ограничить `limit` (например макс. 100), иначе один запрос может положить БД.

### Шаг 4.3 — Эндпоинты GET /api/categories и GET /api/products, GET /api/products/:id
- **GET /api/categories:** без авторизации, вернуть список категорий в формате фронта.
- **GET /api/products:** query-параметры: category, search, sort, page, limit (по умолчанию 12). Фильтры: form, manufacturer, priceMin, priceMax, sale, new. Валидация: page >= 1, limit 1..100. Ответ: список товаров + опционально total count для пагинации.
- **GET /api/products/:id:** 404 если не найден. Не раскрывать внутренние id в ошибках.
- **Предотвращение:** Санитизация search (макс. длина, запрет опасных символов для SQL). При некорректных параметрах — 400 с перечислением ошибок.

### Шаг 4.4 — Seed данных (опционально)
- **Действие:** Отдельная миграция V4 или скрипт: вставить категории и товары из текущего `products.ts` фронта, чтобы каталог сразу был заполнен. Запускать только в dev/test или через флаг.

---

## Фаза 5: Заказы (Orders)

### Шаг 5.1 — Миграция V5: заказы и позиции
- **Таблица orders:** id (BIGSERIAL), order_number (уникальный, человекочитаемый, например DA-202402-00001), user_id (NULL для гостя), guest_phone, guest_name, guest_email, delivery_type (delivery/pickup), address, city, payment_method (card/cash/kaspi), subtotal, discount, delivery_fee, total, status (pending, confirmed, shipped, delivered, cancelled), promo_code, comment, created_at, updated_at.
- **Таблица order_items:** id, order_id (FK), product_id (FK), product_name (денормализация на момент заказа), quantity, price_per_unit.
- **Действие:** Индексы по order_number (unique), user_id, created_at. Внешние ключи с опциональным ON DELETE RESTRICT.
- **Предотвращение:** CHECK на enum-значения status, delivery_type, payment_method. Суммы в копейках или целых единицах (избегать float для денег).

### Шаг 5.2 — OrderRepository и OrderItemRepository
- **Создание заказа:** одна транзакция — вставка order + вставка order_items. Генерация order_number в формате (год-месяц + последовательность за день или глобальная).
- **Предотвращение:** Блокировка при генерации номера (sequence или SELECT FOR UPDATE), чтобы не было дубликатов. Проверка наличия товара и остатков перед созданием заказа; при нехватке — откат и 400 с перечислением позиций.

### Шаг 5.3 — Проверка цен и остатков
- **Проблема:** Фронт может прислать устаревшие цены или количество больше остатка.
- **Действие:** При создании заказа для каждой позиции: взять текущие price и stock из БД. Если stock < запрошенного quantity — ошибка. Использовать актуальную цену из БД при расчёте subtotal (не доверять сумму с фронта). Пересчитать скидку по промокоду на бэкенде.
- **Предотвращение:** Двойная проверка total: пересчитанная сумма должна совпадать с ожидаемой с учётом округления; при расхождении — 400 с сообщением «Корзина изменилась, пересчитайте заказ».

### Шаг 5.4 — Промокоды при заказе
- **Таблица promo_codes (миграция V6 или в V5):** code (unique), discount, type (percent/fixed), min_order, description, active (boolean).
- **Действие:** При создании заказа опционально передаётся promo_code. Проверить: код существует, active, min_order выполнен; применить скидку и записать в order. При неверном коде — 400 с сообщением «Промокод недействителен» (не раскрывать, истёк ли или не существует).
- **Предотвращение:** Один промокод на заказ; не допускать двойного применения скидки.

### Шаг 5.5 — Эндпоинт POST /api/orders
- **Тело:** корзина (массив { productId, quantity }), контакты (name, phone, email?), доставка (type, address?, city?), способ оплаты, комментарий, промокод (опционально). user_id подставлять из JWT, если авторизован; иначе только гостевые поля.
- **Валидация:** Обязательные поля (name, phone, при delivery — address). productId и quantity > 0. Проверка остатков и цен — см. выше.
- **Ответ при успехе:** 201 + тело с order_number и id заказа (и при необходимости полным заказом для отображения на фронте).
- **Ошибки:** Нет товаров в корзине → 400. Нехватка остатков → 400 со списком товаров. Ошибка БД в середине транзакции → rollback, 500.

### Шаг 5.6 — Эндпоинт GET /api/orders
- **Доступ:** только с валидным JWT. Вернуть заказы текущего user_id (по id из токена).
- **Параметры:** page, limit (пагинация). Сортировка по created_at DESC.
- **Гость:** Можно отдельно GET /api/orders/by-phone?phone=...&order_number=... с лимитом попыток (или капча), чтобы гость видел свой заказ по номеру и телефону — опционально, с осторожностью (защита от перебора).

### Шаг 5.7 — Уменьшение остатков при создании заказа
- **Действие:** В той же транзакции, что и создание order/order_items, делать UPDATE products SET stock = stock - quantity WHERE id = ? для каждой позиции. При нехватке stock — откат всей транзакции и 400.
- **Предотвращение:** Использовать пессимистическую блокировку (SELECT FOR UPDATE) по product_id при обновлении остатков, чтобы два одновременных заказа не продали один и тот же последний товар.

---

## Фаза 6: Избранное и доп. возможности

### Шаг 6.1 — Миграция: таблица favorites
- **Поля:** user_id (FK), product_id (FK), created_at. Первичный ключ (user_id, product_id).
- **Действие:** Эндпоинты GET /api/favorites (список id или полных товаров), POST /api/favorites (тело { productId }), DELETE /api/favorites/:productId. Все — только для авторизованных.
- **Предотвращение:** Проверять существование product_id при добавлении; при несуществующем — 404.

### Шаг 6.2 — Логирование и мониторинг
- **Действие:** Логировать входящие запросы (метод, путь, статус, время; без тел с паролями/кодами). Логировать ошибки с trace id (если есть) для разбора инцидентов.
- **Предотвращение:** Не логировать токены, коды OTP, полные номера карт (если появятся) в открытом виде.

### Шаг 6.3 — Валидация входных данных централизованно
- **Действие:** Вынести правила валидации (длина, формат телефона, email, диапазоны чисел) в переиспользуемые функции/аннотации. Использовать их в обработчиках и возвращать 400 с единообразным списком полей и сообщений об ошибках.

### Шаг 6.4 — Таймауты и пулы
- **DataSource:** Настроить HikariCP: max pool size, connection timeout, idle timeout. Предотвращать исчерпание соединений при всплеске нагрузки.
- **HTTP:** Таймаут на чтение запроса и на обработку (например 30 с), чтобы долгий запрос не висел бесконечно.

---

## Чек-лист по безопасности

- [ ] Все SQL-запросы параметризованы (PreparedStatement).
- [ ] Секреты (JWT, OTP, DB) только из переменных окружения или защищённого хранилища.
- [ ] Rate limit на send-code и verify.
- [ ] Одинаковые по форме ответы при успехе/неуспехе auth (не раскрывать «пользователь не найден»).
- [ ] CORS только с явным origin в production.
- [ ] Глобальный exception handler — никаких stack trace в ответе.
- [ ] Токен с ограниченным сроком жизни; при необходимости refresh flow.
- [ ] Остатки и цены при заказе всегда пересчитываются на бэкенде; блокировка при обновлении stock.

---

## Порядок выполнения (кратко)

1. Фаза 0: фреймворк, формат ответов, глобальный exception handler.  
2. Фаза 1: Flyway, V1 sms_codes, запуск миграций при старте.  
3. Фаза 2: HTTP-сервер, CORS, health, заголовки безопасности.  
4. Фаза 3: users (V2), UserRepository, доработка AuthService (user + JWT), send-code/verify/me, rate limit, валидация, OTP генератор.  
5. Фаза 4: products/categories (V3–V4), репозитории, эндпоинты каталога.  
6. Фаза 5: orders (V5–V6), промокоды, создание заказа с проверкой остатков и цен, GET orders.  
7. Фаза 6: favorites, логирование, валидация, пулы и таймауты.

После каждого шага проверять: ручные запросы (curl/Postman), при возможности — автотесты на критичные сценарии (auth, создание заказа, нехватка остатков).
